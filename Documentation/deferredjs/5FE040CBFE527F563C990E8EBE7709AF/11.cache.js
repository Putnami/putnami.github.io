$wnd.Documentation.runAsyncCallback11("function Pcc(){sab(this,Scc(new Tcc(this)))}\nfunction Wcc(a,b){var c;c=new Utc;c.a+=HGc;Rtc(c,V5(a));c.a+=GGc;Rtc(c,V5(b));c.a+=IGc;return new G5(c.a)}\nfunction Scc(a){var b,c,d,e,f,g;c=new etb(Wcc(a.b,a.H).a);jw((H6(),c.L),NGc,'PWT - Server Calls RPC Framework');b=B6(c.L);y6(a.c);y6(a.ab);b.b?Rv(b.b,b.a,b.c):D6(b.a);Qab(c,(d=new htb(Ucc(a.d).a),e=B6(d.L),y6(a.G),e.b?Rv(e.b,e.a,e.c):D6(e.a),Qab(d,(f=new otb(1),mtb(f,(g=new Utc,g.a+=aIc,new G5(g.a)).a),f),y6(a.G)),a.rb.k=d,d),y6(a.c));Qab(c,Rcc(a),y6(a.ab));return c}\nfunction Ucc(a){var b;b=new Utc;b.a+=HGc;Rtc(b,V5(a));b.a+=\"'><\\/span> <p class='lead'> GWT RPC framework makes it easy to invoke service procedure on server. But not easy enough for <strong title='Putnami Web Toolkit'>PWT<\\/strong>. <br> That's why we improved this mechanism in various ways. <\\/p> <ul class='lead'> <li>Writing the full Async interface is no longer required.<\\/li> <li>Use the <code>@AsyncHandler<\\/code> instead to extend <code>AsynCallback<\\/code>.<\\/li> <li>Multiplex your request on a single HttpRequest.<\\/li> <li>Handle <code>CommandEvent<\\/code> to monitor the RPC activity.<\\/li> <li>Delay your request with the <code>@LazyCommand<\\/code> annotation.<\\/li> <\\/ul> <p class='lead'> Without any Async interfaces and inner <code>AsyncCallback<\\/code> declaration,  this feature helps you decrease the number of lines and keep your code readable and simple.  <br> By optimizing the number of HTTP requests, your application is more efficient and reactive. <\\/p>\";return new G5(b.a)}\nfunction Tcc(a){this.rb=a;this.d=_w($doc);this.bb=_w($doc);this.fb=_w($doc);this.hb=_w($doc);this.jb=_w($doc);this.lb=_w($doc);this.nb=_w($doc);this.pb=_w($doc);this.e=_w($doc);this.g=_w($doc);this.j=_w($doc);this.n=_w($doc);this.p=_w($doc);this.s=_w($doc);this.u=_w($doc);this.w=_w($doc);this.B=_w($doc);this.D=_w($doc);this.I=_w($doc);this.K=_w($doc);this.M=_w($doc);this.O=_w($doc);this.Q=_w($doc);this.S=_w($doc);this.U=_w($doc);this.W=_w($doc);this.Y=_w($doc);this.$=_w($doc);this.cb=_w($doc);this.b=_w($doc);this.H=_w($doc);this.G=new z6(this.d);this.eb=new z6(this.bb);this.gb=new z6(this.fb);this.ib=new z6(this.hb);this.kb=new z6(this.jb);this.mb=new z6(this.lb);this.ob=new z6(this.nb);this.qb=new z6(this.pb);this.f=new z6(this.e);this.i=new z6(this.g);this.k=new z6(this.j);this.o=new z6(this.n);this.r=new z6(this.p);this.t=new z6(this.s);this.v=new z6(this.u);this.A=new z6(this.w);this.C=new z6(this.B);this.F=new z6(this.D);this.J=new z6(this.I);this.L=new z6(this.K);this.N=new z6(this.M);this.P=new z6(this.O);this.R=new z6(this.Q);this.T=new z6(this.S);this.V=new z6(this.U);this.X=new z6(this.W);this.Z=new z6(this.Y);this._=new z6(this.$);this.db=new z6(this.cb);this.c=new z6(this.b);this.ab=new z6(this.H);this.a=(Bnc(),Anc)}\nfunction Rcc(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ab,bb,cb,db,eb,fb,gb,hb,ib;c=new etb(Vcc(a.bb,a.fb,a.hb,a.jb,a.lb,a.nb,a.pb,a.e,a.g,a.j,a.n,a.p,a.s,a.u,a.w,a.B,a.D,a.I,a.K,a.M,a.O,a.Q,a.S,a.U,a.W,a.Y,a.$,a.cb).a);b=B6((H6(),c.L));y6(a.eb);y6(a.gb);y6(a.ib);y6(a.kb);y6(a.mb);y6(a.ob);y6(a.qb);y6(a.f);y6(a.i);y6(a.k);y6(a.o);y6(a.r);y6(a.t);y6(a.v);y6(a.A);y6(a.C);y6(a.F);y6(a.J);y6(a.L);y6(a.N);y6(a.P);y6(a.R);y6(a.T);y6(a.V);y6(a.X);y6(a.Z);y6(a._);y6(a.db);b.b?Rv(b.b,b.a,b.c):D6(b.a);Qab(c,(d=new otb(2),mtb(d,(I=new Utc,I.a+=AOc,new G5(I.a)).a),jw(d.L,SJc,TJc),d),y6(a.eb));Qab(c,(e=new emb((J=new Utc,J.a+=\"<h4>Note :<\\/h4> <ul> <li>The CommandService can process more than one request at once.<\\/li> <li>The CommandService doesn't throw any global exception, each exception are wrapped in a CommandResponse.<\\/li> <\\/ul>\",new G5(J.a)).a),cmb(e,(qmb(),nmb)),e),y6(a.gb));Qab(c,(f=new otb(2),mtb(f,(K=new Utc,K.a+='On server side',new G5(K.a)).a),jw(f.L,SJc,TJc),f),y6(a.ib));Qab(c,(g=new emb((L=new Utc,L.a+='<h4>Coming soon :<\\/h4> <ul> <li>J2EE CommandService resolving services in the JNDI<\\/li> <li>Spring CommandService resolving services in the ApplicationContext<\\/li> <\\/ul>',new G5(L.a)).a),cmb(g,nmb),g),y6(a.kb));Qab(c,(h=new otb(3),mtb(h,(M=new Utc,M.a+='BasicCommandService',new G5(M.a)).a),jw(h.L,SJc,TJc),h),y6(a.mb));Qab(c,(i=new anc,_mc(i,(N=new Utc,N.a+='<pre>\\n&lt;!-- Command service servlet --&gt;\\n&lt;servlet&gt;\\n  &lt;servlet-name&gt;commandService&lt;/servlet-name&gt;\\n  &lt;servlet-class&gt;fr.putnami.pwt.core.service.server.service.BasicCommandService&lt;/servlet-class&gt;\\n  &lt;init-param&gt;\\n      &lt;param-name&gt;services&lt;/param-name&gt;\\n      &lt;param-value&gt;fr.putnami.pwt.example.sample.server.service.PersonServiceImpl&lt;/param-value&gt;\\n  &lt;/init-param&gt;\\n&lt;/servlet&gt;\\n&lt;servlet-mapping&gt;\\n  &lt;servlet-name&gt;commandService&lt;/servlet-name&gt;\\n  &lt;url-pattern&gt;Sample/commandService&lt;/url-pattern&gt;\\n&lt;/servlet-mapping&gt;\\n<\\/pre>',new G5(N.a)).a),$mc(i,(Jnc(),Inc)),i),y6(a.ob));Qab(c,(j=new otb(2),mtb(j,(O=new Utc,O.a+='Service proxy',new G5(O.a)).a),jw(j.L,SJc,TJc),j),y6(a.qb));Qab(c,(k=new otb(3),mtb(k,(P=new Utc,P.a+='Basic proxy',new G5(P.a)).a),jw(k.L,SJc,TJc),k),y6(a.f));Qab(c,(l=new anc,_mc(l,(Q=new Utc,Q.a+='<pre>\\n// Remote proxy interface.\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {}\\n\\npublic PersonView(){\\n\\t// rebind the service in an instance. \\n\\tthis.personService = (PersonRemoteService) GWT.create(PersonRemoteService.class);\\n\\t// Bind callbacks with local handler methods.  \\n\\tthis.personService.bindService(this);\\n}\\n<\\/pre>',new G5(Q.a)).a),$mc(l,a.a),l),y6(a.i));Qab(c,(m=new anc,_mc(m,(R=new Utc,R.a+='<pre>\\n@InjectService\\nPersonService personService;\\n<\\/pre>',new G5(R.a)).a),$mc(m,a.a),m),y6(a.k));Qab(c,(n=new otb(3),mtb(n,(S=new Utc,S.a+='Standard async method',new G5(S.a)).a),jw(n.L,SJc,TJc),n),y6(a.o));Qab(c,(o=new anc,_mc(o,(T=new Utc,T.a+='<pre>\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {\\n\\tvoid getPeople(String name, AsyncCallback&lt;Person&gt; callback);\\n}\\n<\\/pre>',new G5(T.a)).a),$mc(o,a.a),o),y6(a.r));Qab(c,(p=new otb(2),mtb(p,(U=new Utc,U.a+='Callbacks',new G5(U.a)).a),jw(p.L,SJc,TJc),p),y6(a.t));Qab(c,(q=new otb(3),mtb(q,(V=new Utc,V.a+='Success callback',new G5(V.a)).a),jw(q.L,SJc,TJc),q),y6(a.v));Qab(c,(r=new anc,_mc(r,(W=new Utc,W.a+='<pre>\\n@AsyncHandler\\nvoid onSavePerson(Person result) {\\n\\t// Do something with the result\\n}\\n@AsyncHandler(method=\"savePerson\")\\nvoid customSavePersonCallback(Person result) {\\n\\t// Do an other hing with the result\\n}\\n<\\/pre>',new G5(W.a)).a),$mc(r,a.a),r),y6(a.A));Qab(c,(s=new otb(3),mtb(s,(X=new Utc,X.a+='Faillure callback',new G5(X.a)).a),jw(s.L,SJc,TJc),s),y6(a.C));Qab(c,(t=new anc,_mc(t,(Y=new Utc,Y.a+='<pre>\\n@AsyncHandler\\nvoid onSavePersonThrown(Throwable thrown) {\\n\\t// Do something with the exception\\n}\\n@AsyncHandler(method=\"savePerson\")\\nvoid customSavePersonThrown(Throwable thrown) {\\n\\t// Do something with the exception\\n}\\n<\\/pre>',new G5(Y.a)).a),$mc(t,a.a),t),y6(a.F));Qab(c,(u=new otb(2),mtb(u,(Z=new Utc,Z.a+='Invoke a service',new G5(Z.a)).a),jw(u.L,SJc,TJc),u),y6(a.J));Qab(c,(v=new otb(3),mtb(v,($=new Utc,$.a+='Single request',new G5($.a)).a),jw(v.L,SJc,TJc),v),y6(a.L));Qab(c,(w=new emb((ab=new Utc,ab.a+='<h4>Note : <\\/h4> <p> All proxy methods return null. the result is be passed to the <code>AsyncHandler<\\/code> <\\/p>',new G5(ab.a)).a),cmb(w,nmb),w),y6(a.N));Qab(c,(A=new anc,_mc(A,(bb=new Utc,bb.a+='<pre>\\n@UiHandler(\"saveButton\")\\nvoid onSaveClick(ClickEvent event){\\n\\tPerson personToSave = ...\\n\\t// Call the remote service\\n\\tthis.personService.savePerson(personToSave);\\n}\\n<\\/pre>',new G5(bb.a)).a),$mc(A,a.a),A),y6(a.P));Qab(c,(B=new otb(3),mtb(B,(cb=new Utc,cb.a+='Multiplex requests',new G5(cb.a)).a),jw(B.L,SJc,TJc),B),y6(a.R));Qab(c,(C=new anc,_mc(C,(db=new Utc,db.a+='<pre>\\nvoid load100Persons(){\\n\\t// allow to stack requests.\\n\\tCommandController.get().setSuspended(true);\\n\\tfor(int i = 0 ; i &lt; 100 ; i++){\\n\\t\\t// does not make any http request.\\n\\t\\tthis.personService.getPerson(i);\\n\\t}\\n\\t// Send the 100 requests over a single http request.\\n\\t// For each request the callback will be called.\\n\\tCommandController.get().flush();\\n}\\n<\\/pre>',new G5(db.a)).a),$mc(C,a.a),C),y6(a.T));Qab(c,(D=new otb(3),mtb(D,(eb=new Utc,eb.a+='Lazy commands',new G5(eb.a)).a),jw(D.L,SJc,TJc),D),y6(a.V));Qab(c,(F=new anc,_mc(F,(fb=new Utc,fb.a+='<pre>\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {\\n\\t@LazyCommand\\n\\tPerson getPerson(Long id);\\n}\\n<\\/pre>',new G5(fb.a)).a),$mc(F,a.a),F),y6(a.X));Qab(c,(G=new otb(2),mtb(G,(gb=new Utc,gb.a+='Events',new G5(gb.a)).a),jw(G.L,SJc,TJc),G),y6(a.Z));Qab(c,new emb((hb=new Utc,hb.a+='<h4>Note :<\\/h4> <p> If the method is annotated as <code>@QuietCommand<\\/code> events are not fired. <\\/p>',new G5(hb.a)).a),y6(a._));Qab(c,(H=new anc,_mc(H,(ib=new Utc,ib.a+='<pre>\\nCommandController.get().addCommandRequestHandler(requestHandler);\\nCommandController.get().addCommandResponseHandler(responseHandler);\\n<\\/pre>',new G5(ib.a)).a),$mc(H,a.a),H),y6(a.db));a.rb.j=c;return c}\nfunction Vcc(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F){var G;G=new Utc;G.a+=HGc;Rtc(G,V5(a));G.a+=\"'><\\/span> <p> This framework is based on a invisible command pattern. This pattern allow to pipe all requests on unique servlet. <\\/p> <p> To make it work you need to: <\\/p> <ul> <li>On the client side you just have to generate a <code>ServiceProxy<\\/code> from the service interface.<\\/li> <li>On the server side you just have to instantiate a single servlet implementing the <code>CommandService<\\/code><\\/li> <\\/ul> <p> When you make a service call, the request flow is: <\\/p> <ol> <li>The <code>ServiceProxy<\\/code> builds one <code>CommandRequest<\\/code><\\/li> <li>The <code>CommandRequest<\\/code> is submited to the <code>CommandController<\\/code>.<\\/li> <li>The <code>CommandController<\\/code> sends a <code>CommandRequestEvent<\\/code> to notify handlers.<\\/li> <li>Then <code>CommandController<\\/code> encodes the <code>CommandRequest<\\/code> in a RPC payload.<\\/li> <li>The <code>CommandController<\\/code> sends the payload over one <code>HttpTequest.<\\/code><\\/li> <li>On the server side, the <code>CommandService<\\/code> handles the <code>CommandRequest<\\/code><\\/li> <li>The <code>CommandRequest<\\/code> is dispatched it to the responsive <code>CommandExecutor<\\/code>.<\\/li> <li>The <code>CommandExecutor<\\/code> invokes the service<\\/li> <li>The <code>CommandExecutor<\\/code> builds a <code>CommandResponse<\\/code> with the result or the exception.<\\/li> <li>The <code>CommandExecutor<\\/code> returns the <code>CommandResponse<\\/code><\\/li> <li>Then <code>CommandService<\\/code> writes <code>CommandResponse<\\/code> on the <code>HttpResponse<\\/code>.<\\/li> <li>Back on the client side, the <code>CommandController<\\/code> handles the <code>CommandResponse<\\/code>.<\\/li> <li>The <code>CommandResponse<\\/code> result or exception is dispatched the to differents binded callbacks.<\\/li> <li>Finally the <code>CommandController<\\/code> sends a <code>CommandResponseEvent<\\/code> to notify handlers.<\\/li> <\\/ol> <span id='\";Rtc(G,V5(b));G.a+=GGc;Rtc(G,V5(c));G.a+=\"'><\\/span> <p> On the server side all requests pass through the <code>CommandService<\\/code>.  <br> The <code>CommandService<\\/code> is in charge to dispatch the <code>CommandRequest<\\/code> to a <code>CommandExecutor<\\/code>. <br> Then <code>CommandExecutor<\\/code> handles <code>CommandRequest<\\/code>, invokes the targeted service then returns a <code>CommandResponse<\\/code>. <\\/p> <span id='\";Rtc(G,V5(d));G.a+=GGc;Rtc(G,V5(e));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> The <code>BasicCommandService<\\/code> is a basic implementation allowing to instantiate services. <\\/p> <\\/div> <span id='\";Rtc(G,V5(f));G.a+=ZJc;Rtc(G,V5(g));G.a+=GGc;Rtc(G,V5(h));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> On the client side you first need to generate a proxy with the following steps: <\\/p> <ol> <li>Declare an interface which extends <code>ServiceProxy&lt;HANDLER, SERVICE&gt;<\\/code>.  <br> <strong>SERVICE<\\/strong> is the interface of the remote service. <br> <strong>HANDLER<\\/strong> is the class on which async callbacks are dispatched. <\\/li> <li>Generate the proxy with <code>GWT.create(...)<\\/code>.  <br> The rebind mechanism will generate the code to make commands and callbacks. <\\/li> <li>Then finally then bind the proxy with the handler <code>proxy.bindService(hadler)<\\/code>. <br> Attach the proxy to the handler, in order to properly dispatch the async callbacks. <\\/li> <\\/ol> <\\/div> <span id='\";Rtc(G,V5(i));G.a+=\"'><\\/span> <p>If you use the <a href='#!Injection'>Injection feature<\\/a> (if the view implements the <code>View<\\/code> interface), you can use the ()very simple) following :<\\/p> <span id='\";Rtc(G,V5(j));G.a+=ZJc;Rtc(G,V5(k));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> To declare standard async method, you have to : <\\/p> <ol> <li>Override the targeted method in the proxy interface.<\\/li> <li>Append an <code>AsyncCallback&lt;RETURN_TYPE&gt;<\\/code> parameter.<\\/li> <li>Set the return type to <strong>void<\\/strong>.<\\/li> <\\/ol> <\\/div> <span id='\";Rtc(G,V5(l));G.a+=ZJc;Rtc(G,V5(m));G.a+=\"'><\\/span> <p> Thanks to the <code>@AsyncHandler<\\/code> you don't need to declare the verbose <code>AsyncCallback<\\/code>.  <br> The annoted methods of the handler are scanned and used to generate the callbacks. <\\/p> <div class='showcase-sample-block'> <span id='\";Rtc(G,V5(n));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The service method name is resolved by convention or with the attribute <code>@AsyncHandler(method=\\\"savePerson\\\")<\\/code>. <\\/p> <p> The convention is : on{methodName with first letter in upper case}[Event]? <\\/p> <p> The method must return void and have one parameter with the expected return type. <br> If the return type is <code>void<\\/code> then the parameter must be <code>Void<\\/code>. <br> If the return type is primitive then the parameter type is the Object type representation. <\\/p> <\\/div> <span id='\";Rtc(G,V5(o));G.a+=GGc;Rtc(G,V5(p));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The service method name is resolved by convention or with the attribute <code>@AsyncHandler(method=\\\"savePerson\\\")<\\/code>. <\\/p> <p> The convention is : on{methodName with first letter in upper case}[Thrown]? <\\/p> <p> The method return void and must have one Throwable parameter. <\\/p> <\\/div> <span id='\";Rtc(G,V5(q));G.a+=$Jc;Rtc(G,V5(r));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <span id='\";Rtc(G,V5(s));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> Server method invokation is a pushover, you just have to invoke the methods on the <code>ServiceProxy<\\/code> then all concerned <code>AsyncHandler<\\/code> are called . <\\/p> <\\/div> <span id='\";Rtc(G,V5(t));G.a+=GGc;Rtc(G,V5(u));G.a+=GGc;Rtc(G,V5(v));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The <code>CommandController<\\/code> helps you suspend requests. When it is flushed the pending requests are collected and sent in a single HTTP Request to the server. On response, each <code>@AsyncHandler<\\/code> is properly called. <\\/p> <\\/div> <span id='\";Rtc(G,V5(w));G.a+=GGc;Rtc(G,V5(A));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> Use the <code>LazyCommand<\\/code> annotation to stack the request untill the next \\\"no lazy\\\" request is done or <code>CommandController<\\/code> is flushed.  <\\/p> <\\/div> <span id='\";Rtc(G,V5(B));G.a+=$Jc;Rtc(G,V5(C));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> Events are fired when <code>CommandController<\\/code> sent and received request. <br> <\\/p> <p> Usage examples: <\\/p> <ul> <li>Make stats.<\\/li> <li>Display a request pending modal.<\\/li> <li>Reset timer to close user session.<\\/li> <\\/ul> <span id='\";Rtc(G,V5(D));G.a+=$Jc;Rtc(G,V5(F));G.a+=NJc;return new G5(G.a)}\nq3(1367,46,OJc);var xZ=trc(BIc,'ServerCallsPage',1367,SU);q3(905,1367,PJc,Pcc);_.th=function Qcc(a,b){G$b(this);b.xe(this)};var tZ=trc(BIc,'ServerCallsPage_Injector',905,xZ);q3(993,1,{},Tcc);var uZ=trc(BIc,'ServerCallsPage_ServerCallsPageTemplateBinder_UiBinderLocalized_BinderImpl/Widgets',993,z1);var Xcc;q3(647,1,jIc);_.Je=function fdc(){var a;!($4(),Xcc)&&(Xcc=new Pcc);a=new J$b;rjb(a,Xcc);kjb(this.a,a)};qEc(Vt)(11);\n//# sourceURL=Documentation-11.js\n")
