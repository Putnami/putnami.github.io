$wnd.Documentation.runAsyncCallback11("function Ncc(){rab(this,Qcc(new Rcc(this)))}\nfunction Ucc(a,b){var c;c=new Stc;c.a+=FGc;Ptc(c,U5(a));c.a+=EGc;Ptc(c,U5(b));c.a+=GGc;return new F5(c.a)}\nfunction Qcc(a){var b,c,d,e,f,g;c=new ctb(Ucc(a.b,a.H).a);jw((G6(),c.L),LGc,'PWT - Server Calls RPC Framework');b=A6(c.L);x6(a.c);x6(a.ab);b.b?Rv(b.b,b.a,b.c):C6(b.a);Pab(c,(d=new ftb(Scc(a.d).a),e=A6(d.L),x6(a.G),e.b?Rv(e.b,e.a,e.c):C6(e.a),Pab(d,(f=new mtb(1),ktb(f,(g=new Stc,g.a+=$Hc,new F5(g.a)).a),f),x6(a.G)),a.rb.k=d,d),x6(a.c));Pab(c,Pcc(a),x6(a.ab));return c}\nfunction Scc(a){var b;b=new Stc;b.a+=FGc;Ptc(b,U5(a));b.a+=\"'><\\/span> <p class='lead'> GWT RPC framework makes it easy to invoke service procedure on server. But not easy enough for <strong title='Putnami Web Toolkit'>PWT<\\/strong>. <br> That's why we improved this mechanism in various ways. <\\/p> <ul class='lead'> <li>Writing the full Async interface is no longer required.<\\/li> <li>Use the <code>@AsyncHandler<\\/code> instead to extend <code>AsynCallback<\\/code>.<\\/li> <li>Multiplex your request on a single HttpRequest.<\\/li> <li>Handle <code>CommandEvent<\\/code> to monitor the RPC activity.<\\/li> <li>Delay your request with the <code>@LazyCommand<\\/code> annotation.<\\/li> <\\/ul> <p class='lead'> Without any Async interfaces and inner <code>AsyncCallback<\\/code> declaration,  this feature helps you decrease the number of lines and keep your code readable and simple.  <br> By optimizing the number of HTTP requests, your application is more efficient and reactive. <\\/p>\";return new F5(b.a)}\nfunction Rcc(a){this.rb=a;this.d=_w($doc);this.bb=_w($doc);this.fb=_w($doc);this.hb=_w($doc);this.jb=_w($doc);this.lb=_w($doc);this.nb=_w($doc);this.pb=_w($doc);this.e=_w($doc);this.g=_w($doc);this.j=_w($doc);this.n=_w($doc);this.p=_w($doc);this.s=_w($doc);this.u=_w($doc);this.w=_w($doc);this.B=_w($doc);this.D=_w($doc);this.I=_w($doc);this.K=_w($doc);this.M=_w($doc);this.O=_w($doc);this.Q=_w($doc);this.S=_w($doc);this.U=_w($doc);this.W=_w($doc);this.Y=_w($doc);this.$=_w($doc);this.cb=_w($doc);this.b=_w($doc);this.H=_w($doc);this.G=new y6(this.d);this.eb=new y6(this.bb);this.gb=new y6(this.fb);this.ib=new y6(this.hb);this.kb=new y6(this.jb);this.mb=new y6(this.lb);this.ob=new y6(this.nb);this.qb=new y6(this.pb);this.f=new y6(this.e);this.i=new y6(this.g);this.k=new y6(this.j);this.o=new y6(this.n);this.r=new y6(this.p);this.t=new y6(this.s);this.v=new y6(this.u);this.A=new y6(this.w);this.C=new y6(this.B);this.F=new y6(this.D);this.J=new y6(this.I);this.L=new y6(this.K);this.N=new y6(this.M);this.P=new y6(this.O);this.R=new y6(this.Q);this.T=new y6(this.S);this.V=new y6(this.U);this.X=new y6(this.W);this.Z=new y6(this.Y);this._=new y6(this.$);this.db=new y6(this.cb);this.c=new y6(this.b);this.ab=new y6(this.H);this.a=(znc(),ync)}\nfunction Pcc(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ab,bb,cb,db,eb,fb,gb,hb,ib;c=new ctb(Tcc(a.bb,a.fb,a.hb,a.jb,a.lb,a.nb,a.pb,a.e,a.g,a.j,a.n,a.p,a.s,a.u,a.w,a.B,a.D,a.I,a.K,a.M,a.O,a.Q,a.S,a.U,a.W,a.Y,a.$,a.cb).a);b=A6((G6(),c.L));x6(a.eb);x6(a.gb);x6(a.ib);x6(a.kb);x6(a.mb);x6(a.ob);x6(a.qb);x6(a.f);x6(a.i);x6(a.k);x6(a.o);x6(a.r);x6(a.t);x6(a.v);x6(a.A);x6(a.C);x6(a.F);x6(a.J);x6(a.L);x6(a.N);x6(a.P);x6(a.R);x6(a.T);x6(a.V);x6(a.X);x6(a.Z);x6(a._);x6(a.db);b.b?Rv(b.b,b.a,b.c):C6(b.a);Pab(c,(d=new mtb(2),ktb(d,(I=new Stc,I.a+=yOc,new F5(I.a)).a),jw(d.L,QJc,RJc),d),x6(a.eb));Pab(c,(e=new cmb((J=new Stc,J.a+=\"<h4>Note :<\\/h4> <ul> <li>The CommandService can process more than one request at once.<\\/li> <li>The CommandService doesn't throw any global exception, each exception are wrapped in a CommandResponse.<\\/li> <\\/ul>\",new F5(J.a)).a),amb(e,(omb(),lmb)),e),x6(a.gb));Pab(c,(f=new mtb(2),ktb(f,(K=new Stc,K.a+='On server side',new F5(K.a)).a),jw(f.L,QJc,RJc),f),x6(a.ib));Pab(c,(g=new cmb((L=new Stc,L.a+='<h4>Coming soon :<\\/h4> <ul> <li>J2EE CommandService resolving services in the JNDI<\\/li> <li>Spring CommandService resolving services in the ApplicationContext<\\/li> <\\/ul>',new F5(L.a)).a),amb(g,lmb),g),x6(a.kb));Pab(c,(h=new mtb(3),ktb(h,(M=new Stc,M.a+='BasicCommandService',new F5(M.a)).a),jw(h.L,QJc,RJc),h),x6(a.mb));Pab(c,(i=new $mc,Zmc(i,(N=new Stc,N.a+='<pre>\\n&lt;!-- Command service servlet --&gt;\\n&lt;servlet&gt;\\n  &lt;servlet-name&gt;commandService&lt;/servlet-name&gt;\\n  &lt;servlet-class&gt;fr.putnami.pwt.core.service.server.service.BasicCommandService&lt;/servlet-class&gt;\\n  &lt;init-param&gt;\\n      &lt;param-name&gt;services&lt;/param-name&gt;\\n      &lt;param-value&gt;fr.putnami.pwt.example.sample.server.service.PersonServiceImpl&lt;/param-value&gt;\\n  &lt;/init-param&gt;\\n&lt;/servlet&gt;\\n&lt;servlet-mapping&gt;\\n  &lt;servlet-name&gt;commandService&lt;/servlet-name&gt;\\n  &lt;url-pattern&gt;Sample/commandService&lt;/url-pattern&gt;\\n&lt;/servlet-mapping&gt;\\n<\\/pre>',new F5(N.a)).a),Ymc(i,(Hnc(),Gnc)),i),x6(a.ob));Pab(c,(j=new mtb(2),ktb(j,(O=new Stc,O.a+='Service proxy',new F5(O.a)).a),jw(j.L,QJc,RJc),j),x6(a.qb));Pab(c,(k=new mtb(3),ktb(k,(P=new Stc,P.a+='Basic proxy',new F5(P.a)).a),jw(k.L,QJc,RJc),k),x6(a.f));Pab(c,(l=new $mc,Zmc(l,(Q=new Stc,Q.a+='<pre>\\n// Remote proxy interface.\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {}\\n\\npublic PersonView(){\\n\\t// rebind the service in an instance. \\n\\tthis.personService = (PersonRemoteService) GWT.create(PersonRemoteService.class);\\n\\t// Bind callbacks with local handler methods.  \\n\\tthis.personService.bindService(this);\\n}\\n<\\/pre>',new F5(Q.a)).a),Ymc(l,a.a),l),x6(a.i));Pab(c,(m=new $mc,Zmc(m,(R=new Stc,R.a+='<pre>\\n@InjectService\\nPersonService personService;\\n<\\/pre>',new F5(R.a)).a),Ymc(m,a.a),m),x6(a.k));Pab(c,(n=new mtb(3),ktb(n,(S=new Stc,S.a+='Standard async method',new F5(S.a)).a),jw(n.L,QJc,RJc),n),x6(a.o));Pab(c,(o=new $mc,Zmc(o,(T=new Stc,T.a+='<pre>\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {\\n\\tvoid getPeople(String name, AsyncCallback&lt;Person&gt; callback);\\n}\\n<\\/pre>',new F5(T.a)).a),Ymc(o,a.a),o),x6(a.r));Pab(c,(p=new mtb(2),ktb(p,(U=new Stc,U.a+='Callbacks',new F5(U.a)).a),jw(p.L,QJc,RJc),p),x6(a.t));Pab(c,(q=new mtb(3),ktb(q,(V=new Stc,V.a+='Success callback',new F5(V.a)).a),jw(q.L,QJc,RJc),q),x6(a.v));Pab(c,(r=new $mc,Zmc(r,(W=new Stc,W.a+='<pre>\\n@AsyncHandler\\nvoid onSavePerson(Person result) {\\n\\t// Do something with the result\\n}\\n@AsyncHandler(method=\"savePerson\")\\nvoid customSavePersonCallback(Person result) {\\n\\t// Do an other hing with the result\\n}\\n<\\/pre>',new F5(W.a)).a),Ymc(r,a.a),r),x6(a.A));Pab(c,(s=new mtb(3),ktb(s,(X=new Stc,X.a+='Faillure callback',new F5(X.a)).a),jw(s.L,QJc,RJc),s),x6(a.C));Pab(c,(t=new $mc,Zmc(t,(Y=new Stc,Y.a+='<pre>\\n@AsyncHandler\\nvoid onSavePersonThrown(Throwable thrown) {\\n\\t// Do something with the exception\\n}\\n@AsyncHandler(method=\"savePerson\")\\nvoid customSavePersonThrown(Throwable thrown) {\\n\\t// Do something with the exception\\n}\\n<\\/pre>',new F5(Y.a)).a),Ymc(t,a.a),t),x6(a.F));Pab(c,(u=new mtb(2),ktb(u,(Z=new Stc,Z.a+='Invoke a service',new F5(Z.a)).a),jw(u.L,QJc,RJc),u),x6(a.J));Pab(c,(v=new mtb(3),ktb(v,($=new Stc,$.a+='Single request',new F5($.a)).a),jw(v.L,QJc,RJc),v),x6(a.L));Pab(c,(w=new cmb((ab=new Stc,ab.a+='<h4>Note : <\\/h4> <p> All proxy methods return null. the result is be passed to the <code>AsyncHandler<\\/code> <\\/p>',new F5(ab.a)).a),amb(w,lmb),w),x6(a.N));Pab(c,(A=new $mc,Zmc(A,(bb=new Stc,bb.a+='<pre>\\n@UiHandler(\"saveButton\")\\nvoid onSaveClick(ClickEvent event){\\n\\tPerson personToSave = ...\\n\\t// Call the remote service\\n\\tthis.personService.savePerson(personToSave);\\n}\\n<\\/pre>',new F5(bb.a)).a),Ymc(A,a.a),A),x6(a.P));Pab(c,(B=new mtb(3),ktb(B,(cb=new Stc,cb.a+='Multiplex requests',new F5(cb.a)).a),jw(B.L,QJc,RJc),B),x6(a.R));Pab(c,(C=new $mc,Zmc(C,(db=new Stc,db.a+='<pre>\\nvoid load100Persons(){\\n\\t// allow to stack requests.\\n\\tCommandController.get().setSuspended(true);\\n\\tfor(int i = 0 ; i &lt; 100 ; i++){\\n\\t\\t// does not make any http request.\\n\\t\\tthis.personService.getPerson(i);\\n\\t}\\n\\t// Send the 100 requests over a single http request.\\n\\t// For each request the callback will be called.\\n\\tCommandController.get().flush();\\n}\\n<\\/pre>',new F5(db.a)).a),Ymc(C,a.a),C),x6(a.T));Pab(c,(D=new mtb(3),ktb(D,(eb=new Stc,eb.a+='Lazy commands',new F5(eb.a)).a),jw(D.L,QJc,RJc),D),x6(a.V));Pab(c,(F=new $mc,Zmc(F,(fb=new Stc,fb.a+='<pre>\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {\\n\\t@LazyCommand\\n\\tPerson getPerson(Long id);\\n}\\n<\\/pre>',new F5(fb.a)).a),Ymc(F,a.a),F),x6(a.X));Pab(c,(G=new mtb(2),ktb(G,(gb=new Stc,gb.a+='Events',new F5(gb.a)).a),jw(G.L,QJc,RJc),G),x6(a.Z));Pab(c,new cmb((hb=new Stc,hb.a+='<h4>Note :<\\/h4> <p> If the method is annotated as <code>@QuietCommand<\\/code> events are not fired. <\\/p>',new F5(hb.a)).a),x6(a._));Pab(c,(H=new $mc,Zmc(H,(ib=new Stc,ib.a+='<pre>\\nCommandController.get().addCommandRequestHandler(requestHandler);\\nCommandController.get().addCommandResponseHandler(responseHandler);\\n<\\/pre>',new F5(ib.a)).a),Ymc(H,a.a),H),x6(a.db));a.rb.j=c;return c}\nfunction Tcc(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F){var G;G=new Stc;G.a+=FGc;Ptc(G,U5(a));G.a+=\"'><\\/span> <p> This framework is based on a invisible command pattern. This pattern allow to pipe all requests on unique servlet. <\\/p> <p> To make it work you need to: <\\/p> <ul> <li>On the client side you just have to generate a <code>ServiceProxy<\\/code> from the service interface.<\\/li> <li>On the server side you just have to instantiate a single servlet implementing the <code>CommandService<\\/code><\\/li> <\\/ul> <p> When you make a service call, the request flow is: <\\/p> <ol> <li>The <code>ServiceProxy<\\/code> builds one <code>CommandRequest<\\/code><\\/li> <li>The <code>CommandRequest<\\/code> is submited to the <code>CommandController<\\/code>.<\\/li> <li>The <code>CommandController<\\/code> sends a <code>CommandRequestEvent<\\/code> to notify handlers.<\\/li> <li>Then <code>CommandController<\\/code> encodes the <code>CommandRequest<\\/code> in a RPC payload.<\\/li> <li>The <code>CommandController<\\/code> sends the payload over one <code>HttpTequest.<\\/code><\\/li> <li>On the server side, the <code>CommandService<\\/code> handles the <code>CommandRequest<\\/code><\\/li> <li>The <code>CommandRequest<\\/code> is dispatched it to the responsive <code>CommandExecutor<\\/code>.<\\/li> <li>The <code>CommandExecutor<\\/code> invokes the service<\\/li> <li>The <code>CommandExecutor<\\/code> builds a <code>CommandResponse<\\/code> with the result or the exception.<\\/li> <li>The <code>CommandExecutor<\\/code> returns the <code>CommandResponse<\\/code><\\/li> <li>Then <code>CommandService<\\/code> writes <code>CommandResponse<\\/code> on the <code>HttpResponse<\\/code>.<\\/li> <li>Back on the client side, the <code>CommandController<\\/code> handles the <code>CommandResponse<\\/code>.<\\/li> <li>The <code>CommandResponse<\\/code> result or exception is dispatched the to differents binded callbacks.<\\/li> <li>Finally the <code>CommandController<\\/code> sends a <code>CommandResponseEvent<\\/code> to notify handlers.<\\/li> <\\/ol> <span id='\";Ptc(G,U5(b));G.a+=EGc;Ptc(G,U5(c));G.a+=\"'><\\/span> <p> On the server side all requests pass through the <code>CommandService<\\/code>.  <br> The <code>CommandService<\\/code> is in charge to dispatch the <code>CommandRequest<\\/code> to a <code>CommandExecutor<\\/code>. <br> Then <code>CommandExecutor<\\/code> handles <code>CommandRequest<\\/code>, invokes the targeted service then returns a <code>CommandResponse<\\/code>. <\\/p> <span id='\";Ptc(G,U5(d));G.a+=EGc;Ptc(G,U5(e));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> The <code>BasicCommandService<\\/code> is a basic implementation allowing to instantiate services. <\\/p> <\\/div> <span id='\";Ptc(G,U5(f));G.a+=XJc;Ptc(G,U5(g));G.a+=EGc;Ptc(G,U5(h));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> On the client side you first need to generate a proxy with the following steps: <\\/p> <ol> <li>Declare an interface which extends <code>ServiceProxy&lt;HANDLER, SERVICE&gt;<\\/code>.  <br> <strong>SERVICE<\\/strong> is the interface of the remote service. <br> <strong>HANDLER<\\/strong> is the class on which async callbacks are dispatched. <\\/li> <li>Generate the proxy with <code>GWT.create(...)<\\/code>.  <br> The rebind mechanism will generate the code to make commands and callbacks. <\\/li> <li>Then finally then bind the proxy with the handler <code>proxy.bindService(hadler)<\\/code>. <br> Attach the proxy to the handler, in order to properly dispatch the async callbacks. <\\/li> <\\/ol> <\\/div> <span id='\";Ptc(G,U5(i));G.a+=\"'><\\/span> <p>If you use the <a href='#!Injection'>Injection feature<\\/a> (if the view implements the <code>View<\\/code> interface), you can use the ()very simple) following :<\\/p> <span id='\";Ptc(G,U5(j));G.a+=XJc;Ptc(G,U5(k));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> To declare standard async method, you have to : <\\/p> <ol> <li>Override the targeted method in the proxy interface.<\\/li> <li>Append an <code>AsyncCallback&lt;RETURN_TYPE&gt;<\\/code> parameter.<\\/li> <li>Set the return type to <strong>void<\\/strong>.<\\/li> <\\/ol> <\\/div> <span id='\";Ptc(G,U5(l));G.a+=XJc;Ptc(G,U5(m));G.a+=\"'><\\/span> <p> Thanks to the <code>@AsyncHandler<\\/code> you don't need to declare the verbose <code>AsyncCallback<\\/code>.  <br> The annoted methods of the handler are scanned and used to generate the callbacks. <\\/p> <div class='showcase-sample-block'> <span id='\";Ptc(G,U5(n));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The service method name is resolved by convention or with the attribute <code>@AsyncHandler(method=\\\"savePerson\\\")<\\/code>. <\\/p> <p> The convention is : on{methodName with first letter in upper case}[Event]? <\\/p> <p> The method must return void and have one parameter with the expected return type. <br> If the return type is <code>void<\\/code> then the parameter must be <code>Void<\\/code>. <br> If the return type is primitive then the parameter type is the Object type representation. <\\/p> <\\/div> <span id='\";Ptc(G,U5(o));G.a+=EGc;Ptc(G,U5(p));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The service method name is resolved by convention or with the attribute <code>@AsyncHandler(method=\\\"savePerson\\\")<\\/code>. <\\/p> <p> The convention is : on{methodName with first letter in upper case}[Thrown]? <\\/p> <p> The method return void and must have one Throwable parameter. <\\/p> <\\/div> <span id='\";Ptc(G,U5(q));G.a+=YJc;Ptc(G,U5(r));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <span id='\";Ptc(G,U5(s));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> Server method invokation is a pushover, you just have to invoke the methods on the <code>ServiceProxy<\\/code> then all concerned <code>AsyncHandler<\\/code> are called . <\\/p> <\\/div> <span id='\";Ptc(G,U5(t));G.a+=EGc;Ptc(G,U5(u));G.a+=EGc;Ptc(G,U5(v));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The <code>CommandController<\\/code> helps you suspend requests. When it is flushed the pending requests are collected and sent in a single HTTP Request to the server. On response, each <code>@AsyncHandler<\\/code> is properly called. <\\/p> <\\/div> <span id='\";Ptc(G,U5(w));G.a+=EGc;Ptc(G,U5(A));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> Use the <code>LazyCommand<\\/code> annotation to stack the request untill the next \\\"no lazy\\\" request is done or <code>CommandController<\\/code> is flushed.  <\\/p> <\\/div> <span id='\";Ptc(G,U5(B));G.a+=YJc;Ptc(G,U5(C));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> Events are fired when <code>CommandController<\\/code> sent and received request. <br> <\\/p> <p> Usage examples: <\\/p> <ul> <li>Make stats.<\\/li> <li>Display a request pending modal.<\\/li> <li>Reset timer to close user session.<\\/li> <\\/ul> <span id='\";Ptc(G,U5(D));G.a+=YJc;Ptc(G,U5(F));G.a+=LJc;return new F5(G.a)}\np3(1366,46,MJc);var wZ=qrc(zIc,'ServerCallsPage',1366,RU);p3(905,1366,NJc,Ncc);_.th=function Occ(a,b){E$b(this);b.xe(this)};var sZ=qrc(zIc,'ServerCallsPage_Injector',905,wZ);p3(993,1,{},Rcc);var tZ=qrc(zIc,'ServerCallsPage_ServerCallsPageTemplateBinder_UiBinderLocalized_BinderImpl/Widgets',993,y1);var Vcc;p3(647,1,hIc);_.Je=function ddc(){var a;!(Z4(),Vcc)&&(Vcc=new Ncc);a=new H$b;pjb(a,Vcc);ijb(this.a,a)};oEc(Vt)(11);\n//# sourceURL=Documentation-11.js\n")
