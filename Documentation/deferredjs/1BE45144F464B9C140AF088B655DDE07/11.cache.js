$wnd.Documentation.runAsyncCallback11("function $cc(){pab(this,bdc(new cdc(this)))}\nfunction fdc(a,b){var c;c=new duc;c.a+=UGc;auc(c,X5(a));c.a+=TGc;auc(c,X5(b));c.a+=VGc;return new I5(c.a)}\nfunction bdc(a){var b,c,d,e,f,g;c=new otb(fdc(a.b,a.H).a);jw((J6(),c.L),$Gc,'PWT - Server Calls RPC Framework');b=D6(c.L);A6(a.c);A6(a.ab);b.b?Rv(b.b,b.a,b.c):F6(b.a);Nab(c,(d=new rtb(ddc(a.d).a),e=D6(d.L),A6(a.G),e.b?Rv(e.b,e.a,e.c):F6(e.a),Nab(d,(f=new ytb(1),wtb(f,(g=new duc,g.a+=nIc,new I5(g.a)).a),f),A6(a.G)),a.rb.k=d,d),A6(a.c));Nab(c,adc(a),A6(a.ab));return c}\nfunction ddc(a){var b;b=new duc;b.a+=UGc;auc(b,X5(a));b.a+=\"'><\\/span> <p class='lead'> GWT RPC framework makes it easy to invoke service procedure on server. But not easy enough for <strong title='Putnami Web Toolkit'>PWT<\\/strong>. <br> That's why we improved this mechanism in various ways. <\\/p> <ul class='lead'> <li>Writing the full Async interface is no longer required.<\\/li> <li>Use the <code>@AsyncHandler<\\/code> instead to extend <code>AsynCallback<\\/code>.<\\/li> <li>Multiplex your request on a single HttpRequest.<\\/li> <li>Handle <code>CommandEvent<\\/code> to monitor the RPC activity.<\\/li> <li>Delay your request with the <code>@LazyCommand<\\/code> annotation.<\\/li> <\\/ul> <p class='lead'> Without any Async interfaces and inner <code>AsyncCallback<\\/code> declaration,  this feature helps you decrease the number of lines and keep your code readable and simple.  <br> By optimizing the number of HTTP requests, your application is more efficient and reactive. <\\/p>\";return new I5(b.a)}\nfunction cdc(a){this.rb=a;this.d=cx($doc);this.bb=cx($doc);this.fb=cx($doc);this.hb=cx($doc);this.jb=cx($doc);this.lb=cx($doc);this.nb=cx($doc);this.pb=cx($doc);this.e=cx($doc);this.g=cx($doc);this.j=cx($doc);this.n=cx($doc);this.p=cx($doc);this.s=cx($doc);this.u=cx($doc);this.w=cx($doc);this.B=cx($doc);this.D=cx($doc);this.I=cx($doc);this.K=cx($doc);this.M=cx($doc);this.O=cx($doc);this.Q=cx($doc);this.S=cx($doc);this.U=cx($doc);this.W=cx($doc);this.Y=cx($doc);this.$=cx($doc);this.cb=cx($doc);this.b=cx($doc);this.H=cx($doc);this.G=new B6(this.d);this.eb=new B6(this.bb);this.gb=new B6(this.fb);this.ib=new B6(this.hb);this.kb=new B6(this.jb);this.mb=new B6(this.lb);this.ob=new B6(this.nb);this.qb=new B6(this.pb);this.f=new B6(this.e);this.i=new B6(this.g);this.k=new B6(this.j);this.o=new B6(this.n);this.r=new B6(this.p);this.t=new B6(this.s);this.v=new B6(this.u);this.A=new B6(this.w);this.C=new B6(this.B);this.F=new B6(this.D);this.J=new B6(this.I);this.L=new B6(this.K);this.N=new B6(this.M);this.P=new B6(this.O);this.R=new B6(this.Q);this.T=new B6(this.S);this.V=new B6(this.U);this.X=new B6(this.W);this.Z=new B6(this.Y);this._=new B6(this.$);this.db=new B6(this.cb);this.c=new B6(this.b);this.ab=new B6(this.H);this.a=(Mnc(),Lnc)}\nfunction adc(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ab,bb,cb,db,eb,fb,gb,hb,ib;c=new otb(edc(a.bb,a.fb,a.hb,a.jb,a.lb,a.nb,a.pb,a.e,a.g,a.j,a.n,a.p,a.s,a.u,a.w,a.B,a.D,a.I,a.K,a.M,a.O,a.Q,a.S,a.U,a.W,a.Y,a.$,a.cb).a);b=D6((J6(),c.L));A6(a.eb);A6(a.gb);A6(a.ib);A6(a.kb);A6(a.mb);A6(a.ob);A6(a.qb);A6(a.f);A6(a.i);A6(a.k);A6(a.o);A6(a.r);A6(a.t);A6(a.v);A6(a.A);A6(a.C);A6(a.F);A6(a.J);A6(a.L);A6(a.N);A6(a.P);A6(a.R);A6(a.T);A6(a.V);A6(a.X);A6(a.Z);A6(a._);A6(a.db);b.b?Rv(b.b,b.a,b.c):F6(b.a);Nab(c,(d=new ytb(2),wtb(d,(I=new duc,I.a+=NOc,new I5(I.a)).a),jw(d.L,dKc,eKc),d),A6(a.eb));Nab(c,(e=new lmb((J=new duc,J.a+=\"<h4>Note :<\\/h4> <ul> <li>The CommandService can process more than one request at once.<\\/li> <li>The CommandService doesn't throw any global exception, each exception are wrapped in a CommandResponse.<\\/li> <\\/ul>\",new I5(J.a)).a),jmb(e,(xmb(),umb)),e),A6(a.gb));Nab(c,(f=new ytb(2),wtb(f,(K=new duc,K.a+='On server side',new I5(K.a)).a),jw(f.L,dKc,eKc),f),A6(a.ib));Nab(c,(g=new lmb((L=new duc,L.a+='<h4>Coming soon :<\\/h4> <ul> <li>J2EE CommandService resolving services in the JNDI<\\/li> <li>Spring CommandService resolving services in the ApplicationContext<\\/li> <\\/ul>',new I5(L.a)).a),jmb(g,umb),g),A6(a.kb));Nab(c,(h=new ytb(3),wtb(h,(M=new duc,M.a+='BasicCommandService',new I5(M.a)).a),jw(h.L,dKc,eKc),h),A6(a.mb));Nab(c,(i=new lnc,knc(i,(N=new duc,N.a+='<pre>\\n&lt;!-- Command service servlet --&gt;\\n&lt;servlet&gt;\\n  &lt;servlet-name&gt;commandService&lt;/servlet-name&gt;\\n  &lt;servlet-class&gt;fr.putnami.pwt.core.service.server.service.BasicCommandService&lt;/servlet-class&gt;\\n  &lt;init-param&gt;\\n      &lt;param-name&gt;services&lt;/param-name&gt;\\n      &lt;param-value&gt;fr.putnami.pwt.example.sample.server.service.PersonServiceImpl&lt;/param-value&gt;\\n  &lt;/init-param&gt;\\n&lt;/servlet&gt;\\n&lt;servlet-mapping&gt;\\n  &lt;servlet-name&gt;commandService&lt;/servlet-name&gt;\\n  &lt;url-pattern&gt;Sample/commandService&lt;/url-pattern&gt;\\n&lt;/servlet-mapping&gt;\\n<\\/pre>',new I5(N.a)).a),jnc(i,(Unc(),Tnc)),i),A6(a.ob));Nab(c,(j=new ytb(2),wtb(j,(O=new duc,O.a+='Service proxy',new I5(O.a)).a),jw(j.L,dKc,eKc),j),A6(a.qb));Nab(c,(k=new ytb(3),wtb(k,(P=new duc,P.a+='Basic proxy',new I5(P.a)).a),jw(k.L,dKc,eKc),k),A6(a.f));Nab(c,(l=new lnc,knc(l,(Q=new duc,Q.a+='<pre>\\n// Remote proxy interface.\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {}\\n\\npublic PersonView(){\\n\\t// rebind the service in an instance. \\n\\tthis.personService = (PersonRemoteService) GWT.create(PersonRemoteService.class);\\n\\t// Bind callbacks with local handler methods.  \\n\\tthis.personService.bindService(this);\\n}\\n<\\/pre>',new I5(Q.a)).a),jnc(l,a.a),l),A6(a.i));Nab(c,(m=new lnc,knc(m,(R=new duc,R.a+='<pre>\\n@InjectService\\nPersonService personService;\\n<\\/pre>',new I5(R.a)).a),jnc(m,a.a),m),A6(a.k));Nab(c,(n=new ytb(3),wtb(n,(S=new duc,S.a+='Standard async method',new I5(S.a)).a),jw(n.L,dKc,eKc),n),A6(a.o));Nab(c,(o=new lnc,knc(o,(T=new duc,T.a+='<pre>\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {\\n\\tvoid getPeople(String name, AsyncCallback&lt;Person&gt; callback);\\n}\\n<\\/pre>',new I5(T.a)).a),jnc(o,a.a),o),A6(a.r));Nab(c,(p=new ytb(2),wtb(p,(U=new duc,U.a+='Callbacks',new I5(U.a)).a),jw(p.L,dKc,eKc),p),A6(a.t));Nab(c,(q=new ytb(3),wtb(q,(V=new duc,V.a+='Success callback',new I5(V.a)).a),jw(q.L,dKc,eKc),q),A6(a.v));Nab(c,(r=new lnc,knc(r,(W=new duc,W.a+='<pre>\\n@AsyncHandler\\nvoid onSavePerson(Person result) {\\n\\t// Do something with the result\\n}\\n@AsyncHandler(method=\"savePerson\")\\nvoid customSavePersonCallback(Person result) {\\n\\t// Do an other hing with the result\\n}\\n<\\/pre>',new I5(W.a)).a),jnc(r,a.a),r),A6(a.A));Nab(c,(s=new ytb(3),wtb(s,(X=new duc,X.a+='Faillure callback',new I5(X.a)).a),jw(s.L,dKc,eKc),s),A6(a.C));Nab(c,(t=new lnc,knc(t,(Y=new duc,Y.a+='<pre>\\n@AsyncHandler\\nvoid onSavePersonThrown(Throwable thrown) {\\n\\t// Do something with the exception\\n}\\n@AsyncHandler(method=\"savePerson\")\\nvoid customSavePersonThrown(Throwable thrown) {\\n\\t// Do something with the exception\\n}\\n<\\/pre>',new I5(Y.a)).a),jnc(t,a.a),t),A6(a.F));Nab(c,(u=new ytb(2),wtb(u,(Z=new duc,Z.a+='Invoke a service',new I5(Z.a)).a),jw(u.L,dKc,eKc),u),A6(a.J));Nab(c,(v=new ytb(3),wtb(v,($=new duc,$.a+='Single request',new I5($.a)).a),jw(v.L,dKc,eKc),v),A6(a.L));Nab(c,(w=new lmb((ab=new duc,ab.a+='<h4>Note : <\\/h4> <p> All proxy methods return null. the result is be passed to the <code>AsyncHandler<\\/code> <\\/p>',new I5(ab.a)).a),jmb(w,umb),w),A6(a.N));Nab(c,(A=new lnc,knc(A,(bb=new duc,bb.a+='<pre>\\n@UiHandler(\"saveButton\")\\nvoid onSaveClick(ClickEvent event){\\n\\tPerson personToSave = ...\\n\\t// Call the remote service\\n\\tthis.personService.savePerson(personToSave);\\n}\\n<\\/pre>',new I5(bb.a)).a),jnc(A,a.a),A),A6(a.P));Nab(c,(B=new ytb(3),wtb(B,(cb=new duc,cb.a+='Multiplex requests',new I5(cb.a)).a),jw(B.L,dKc,eKc),B),A6(a.R));Nab(c,(C=new lnc,knc(C,(db=new duc,db.a+='<pre>\\nvoid load100Persons(){\\n\\t// allow to stack requests.\\n\\tCommandController.get().setSuspended(true);\\n\\tfor(int i = 0 ; i &lt; 100 ; i++){\\n\\t\\t// does not make any http request.\\n\\t\\tthis.personService.getPerson(i);\\n\\t}\\n\\t// Send the 100 requests over a single http request.\\n\\t// For each request the callback will be called.\\n\\tCommandController.get().flush();\\n}\\n<\\/pre>',new I5(db.a)).a),jnc(C,a.a),C),A6(a.T));Nab(c,(D=new ytb(3),wtb(D,(eb=new duc,eb.a+='Lazy commands',new I5(eb.a)).a),jw(D.L,dKc,eKc),D),A6(a.V));Nab(c,(F=new lnc,knc(F,(fb=new duc,fb.a+='<pre>\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {\\n\\t@LazyCommand\\n\\tPerson getPerson(Long id);\\n}\\n<\\/pre>',new I5(fb.a)).a),jnc(F,a.a),F),A6(a.X));Nab(c,(G=new ytb(2),wtb(G,(gb=new duc,gb.a+='Events',new I5(gb.a)).a),jw(G.L,dKc,eKc),G),A6(a.Z));Nab(c,new lmb((hb=new duc,hb.a+='<h4>Note :<\\/h4> <p> If the method is annotated as <code>@QuietCommand<\\/code> events are not fired. <\\/p>',new I5(hb.a)).a),A6(a._));Nab(c,(H=new lnc,knc(H,(ib=new duc,ib.a+='<pre>\\nCommandController.get().addCommandRequestHandler(requestHandler);\\nCommandController.get().addCommandResponseHandler(responseHandler);\\n<\\/pre>',new I5(ib.a)).a),jnc(H,a.a),H),A6(a.db));a.rb.j=c;return c}\nfunction edc(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F){var G;G=new duc;G.a+=UGc;auc(G,X5(a));G.a+=\"'><\\/span> <p> This framework is based on a invisible command pattern. This pattern allow to pipe all requests on unique servlet. <\\/p> <p> To make it work you need to: <\\/p> <ul> <li>On the client side you just have to generate a <code>ServiceProxy<\\/code> from the service interface.<\\/li> <li>On the server side you just have to instantiate a single servlet implementing the <code>CommandService<\\/code><\\/li> <\\/ul> <p> When you make a service call, the request flow is: <\\/p> <ol> <li>The <code>ServiceProxy<\\/code> builds one <code>CommandRequest<\\/code><\\/li> <li>The <code>CommandRequest<\\/code> is submited to the <code>CommandController<\\/code>.<\\/li> <li>The <code>CommandController<\\/code> sends a <code>CommandRequestEvent<\\/code> to notify handlers.<\\/li> <li>Then <code>CommandController<\\/code> encodes the <code>CommandRequest<\\/code> in a RPC payload.<\\/li> <li>The <code>CommandController<\\/code> sends the payload over one <code>HttpTequest.<\\/code><\\/li> <li>On the server side, the <code>CommandService<\\/code> handles the <code>CommandRequest<\\/code><\\/li> <li>The <code>CommandRequest<\\/code> is dispatched it to the responsive <code>CommandExecutor<\\/code>.<\\/li> <li>The <code>CommandExecutor<\\/code> invokes the service<\\/li> <li>The <code>CommandExecutor<\\/code> builds a <code>CommandResponse<\\/code> with the result or the exception.<\\/li> <li>The <code>CommandExecutor<\\/code> returns the <code>CommandResponse<\\/code><\\/li> <li>Then <code>CommandService<\\/code> writes <code>CommandResponse<\\/code> on the <code>HttpResponse<\\/code>.<\\/li> <li>Back on the client side, the <code>CommandController<\\/code> handles the <code>CommandResponse<\\/code>.<\\/li> <li>The <code>CommandResponse<\\/code> result or exception is dispatched the to differents binded callbacks.<\\/li> <li>Finally the <code>CommandController<\\/code> sends a <code>CommandResponseEvent<\\/code> to notify handlers.<\\/li> <\\/ol> <span id='\";auc(G,X5(b));G.a+=TGc;auc(G,X5(c));G.a+=\"'><\\/span> <p> On the server side all requests pass through the <code>CommandService<\\/code>.  <br> The <code>CommandService<\\/code> is in charge to dispatch the <code>CommandRequest<\\/code> to a <code>CommandExecutor<\\/code>. <br> Then <code>CommandExecutor<\\/code> handles <code>CommandRequest<\\/code>, invokes the targeted service then returns a <code>CommandResponse<\\/code>. <\\/p> <span id='\";auc(G,X5(d));G.a+=TGc;auc(G,X5(e));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> The <code>BasicCommandService<\\/code> is a basic implementation allowing to instantiate services. <\\/p> <\\/div> <span id='\";auc(G,X5(f));G.a+=kKc;auc(G,X5(g));G.a+=TGc;auc(G,X5(h));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> On the client side you first need to generate a proxy with the following steps: <\\/p> <ol> <li>Declare an interface which extends <code>ServiceProxy&lt;HANDLER, SERVICE&gt;<\\/code>.  <br> <strong>SERVICE<\\/strong> is the interface of the remote service. <br> <strong>HANDLER<\\/strong> is the class on which async callbacks are dispatched. <\\/li> <li>Generate the proxy with <code>GWT.create(...)<\\/code>.  <br> The rebind mechanism will generate the code to make commands and callbacks. <\\/li> <li>Then finally then bind the proxy with the handler <code>proxy.bindService(hadler)<\\/code>. <br> Attach the proxy to the handler, in order to properly dispatch the async callbacks. <\\/li> <\\/ol> <\\/div> <span id='\";auc(G,X5(i));G.a+=\"'><\\/span> <p>If you use the <a href='#!Injection'>Injection feature<\\/a> (if the view implements the <code>View<\\/code> interface), you can use the ()very simple) following :<\\/p> <span id='\";auc(G,X5(j));G.a+=kKc;auc(G,X5(k));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> To declare standard async method, you have to : <\\/p> <ol> <li>Override the targeted method in the proxy interface.<\\/li> <li>Append an <code>AsyncCallback&lt;RETURN_TYPE&gt;<\\/code> parameter.<\\/li> <li>Set the return type to <strong>void<\\/strong>.<\\/li> <\\/ol> <\\/div> <span id='\";auc(G,X5(l));G.a+=kKc;auc(G,X5(m));G.a+=\"'><\\/span> <p> Thanks to the <code>@AsyncHandler<\\/code> you don't need to declare the verbose <code>AsyncCallback<\\/code>.  <br> The annoted methods of the handler are scanned and used to generate the callbacks. <\\/p> <div class='showcase-sample-block'> <span id='\";auc(G,X5(n));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The service method name is resolved by convention or with the attribute <code>@AsyncHandler(method=\\\"savePerson\\\")<\\/code>. <\\/p> <p> The convention is : on{methodName with first letter in upper case}[Event]? <\\/p> <p> The method must return void and have one parameter with the expected return type. <br> If the return type is <code>void<\\/code> then the parameter must be <code>Void<\\/code>. <br> If the return type is primitive then the parameter type is the Object type representation. <\\/p> <\\/div> <span id='\";auc(G,X5(o));G.a+=TGc;auc(G,X5(p));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The service method name is resolved by convention or with the attribute <code>@AsyncHandler(method=\\\"savePerson\\\")<\\/code>. <\\/p> <p> The convention is : on{methodName with first letter in upper case}[Thrown]? <\\/p> <p> The method return void and must have one Throwable parameter. <\\/p> <\\/div> <span id='\";auc(G,X5(q));G.a+=lKc;auc(G,X5(r));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <span id='\";auc(G,X5(s));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> Server method invokation is a pushover, you just have to invoke the methods on the <code>ServiceProxy<\\/code> then all concerned <code>AsyncHandler<\\/code> are called . <\\/p> <\\/div> <span id='\";auc(G,X5(t));G.a+=TGc;auc(G,X5(u));G.a+=TGc;auc(G,X5(v));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The <code>CommandController<\\/code> helps you suspend requests. When it is flushed the pending requests are collected and sent in a single HTTP Request to the server. On response, each <code>@AsyncHandler<\\/code> is properly called. <\\/p> <\\/div> <span id='\";auc(G,X5(w));G.a+=TGc;auc(G,X5(A));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> Use the <code>LazyCommand<\\/code> annotation to stack the request untill the next \\\"no lazy\\\" request is done or <code>CommandController<\\/code> is flushed.  <\\/p> <\\/div> <span id='\";auc(G,X5(B));G.a+=lKc;auc(G,X5(C));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> Events are fired when <code>CommandController<\\/code> sent and received request. <br> <\\/p> <p> Usage examples: <\\/p> <ul> <li>Make stats.<\\/li> <li>Display a request pending modal.<\\/li> <li>Reset timer to close user session.<\\/li> <\\/ul> <span id='\";auc(G,X5(D));G.a+=lKc;auc(G,X5(F));G.a+=$Jc;return new I5(G.a)}\ns3(1365,46,_Jc);var zZ=Erc(OIc,'ServerCallsPage',1365,UU);s3(904,1365,aKc,$cc);_.vh=function _cc(a,b){R$b(this);b.xe(this)};var vZ=Erc(OIc,'ServerCallsPage_Injector',904,zZ);s3(992,1,{},cdc);var wZ=Erc(OIc,'ServerCallsPage_ServerCallsPageTemplateBinder_UiBinderLocalized_BinderImpl/Widgets',992,B1);var gdc;s3(647,1,wIc);_.Je=function qdc(){var a;!(a5(),gdc)&&(gdc=new $cc);a=new U$b;yjb(a,gdc);rjb(this.a,a)};BEc(Vt)(11);\n//# sourceURL=Documentation-11.js\n")
