$wnd.Documentation.runAsyncCallback11("function Tcc(){oab(this,Wcc(new Xcc(this)))}\nfunction $cc(a,b){var c;c=new Ytc;c.a+=PGc;Vtc(c,X5(a));c.a+=OGc;Vtc(c,X5(b));c.a+=QGc;return new I5(c.a)}\nfunction Wcc(a){var b,c,d,e,f,g;c=new itb($cc(a.b,a.H).a);lw((J6(),c.L),VGc,'PWT - Server Calls RPC Framework');b=D6(c.L);A6(a.c);A6(a.ab);b.b?Rv(b.b,b.a,b.c):F6(b.a);Mab(c,(d=new ltb(Ycc(a.d).a),e=D6(d.L),A6(a.G),e.b?Rv(e.b,e.a,e.c):F6(e.a),Mab(d,(f=new stb(1),qtb(f,(g=new Ytc,g.a+=iIc,new I5(g.a)).a),f),A6(a.G)),a.rb.k=d,d),A6(a.c));Mab(c,Vcc(a),A6(a.ab));return c}\nfunction Ycc(a){var b;b=new Ytc;b.a+=PGc;Vtc(b,X5(a));b.a+=\"'><\\/span> <p class='lead'> GWT RPC framework makes it easy to invoke service procedure on server. But not easy enough for <strong title='Putnami Web Toolkit'>PWT<\\/strong>. <br> That's why we improved this mechanism in various ways. <\\/p> <ul class='lead'> <li>Writing the full Async interface is no longer required.<\\/li> <li>Use the <code>@AsyncHandler<\\/code> instead to extend <code>AsynCallback<\\/code>.<\\/li> <li>Multiplex your request on a single HttpRequest.<\\/li> <li>Handle <code>CommandEvent<\\/code> to monitor the RPC activity.<\\/li> <li>Delay your request with the <code>@LazyCommand<\\/code> annotation.<\\/li> <\\/ul> <p class='lead'> Without any Async interfaces and inner <code>AsyncCallback<\\/code> declaration,  this feature helps you decrease the number of lines and keep your code readable and simple.  <br> By optimizing the number of HTTP requests, your application is more efficient and reactive. <\\/p>\";return new I5(b.a)}\nfunction Xcc(a){this.rb=a;this.d=bx($doc);this.bb=bx($doc);this.fb=bx($doc);this.hb=bx($doc);this.jb=bx($doc);this.lb=bx($doc);this.nb=bx($doc);this.pb=bx($doc);this.e=bx($doc);this.g=bx($doc);this.j=bx($doc);this.n=bx($doc);this.p=bx($doc);this.s=bx($doc);this.u=bx($doc);this.w=bx($doc);this.B=bx($doc);this.D=bx($doc);this.I=bx($doc);this.K=bx($doc);this.M=bx($doc);this.O=bx($doc);this.Q=bx($doc);this.S=bx($doc);this.U=bx($doc);this.W=bx($doc);this.Y=bx($doc);this.$=bx($doc);this.cb=bx($doc);this.b=bx($doc);this.H=bx($doc);this.G=new B6(this.d);this.eb=new B6(this.bb);this.gb=new B6(this.fb);this.ib=new B6(this.hb);this.kb=new B6(this.jb);this.mb=new B6(this.lb);this.ob=new B6(this.nb);this.qb=new B6(this.pb);this.f=new B6(this.e);this.i=new B6(this.g);this.k=new B6(this.j);this.o=new B6(this.n);this.r=new B6(this.p);this.t=new B6(this.s);this.v=new B6(this.u);this.A=new B6(this.w);this.C=new B6(this.B);this.F=new B6(this.D);this.J=new B6(this.I);this.L=new B6(this.K);this.N=new B6(this.M);this.P=new B6(this.O);this.R=new B6(this.Q);this.T=new B6(this.S);this.V=new B6(this.U);this.X=new B6(this.W);this.Z=new B6(this.Y);this._=new B6(this.$);this.db=new B6(this.cb);this.c=new B6(this.b);this.ab=new B6(this.H);this.a=(Fnc(),Enc)}\nfunction Vcc(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ab,bb,cb,db,eb,fb,gb,hb,ib;c=new itb(Zcc(a.bb,a.fb,a.hb,a.jb,a.lb,a.nb,a.pb,a.e,a.g,a.j,a.n,a.p,a.s,a.u,a.w,a.B,a.D,a.I,a.K,a.M,a.O,a.Q,a.S,a.U,a.W,a.Y,a.$,a.cb).a);b=D6((J6(),c.L));A6(a.eb);A6(a.gb);A6(a.ib);A6(a.kb);A6(a.mb);A6(a.ob);A6(a.qb);A6(a.f);A6(a.i);A6(a.k);A6(a.o);A6(a.r);A6(a.t);A6(a.v);A6(a.A);A6(a.C);A6(a.F);A6(a.J);A6(a.L);A6(a.N);A6(a.P);A6(a.R);A6(a.T);A6(a.V);A6(a.X);A6(a.Z);A6(a._);A6(a.db);b.b?Rv(b.b,b.a,b.c):F6(b.a);Mab(c,(d=new stb(2),qtb(d,(I=new Ytc,I.a+=HOc,new I5(I.a)).a),lw(d.L,$Jc,_Jc),d),A6(a.eb));Mab(c,(e=new imb((J=new Ytc,J.a+=\"<h4>Note :<\\/h4> <ul> <li>The CommandService can process more than one request at once.<\\/li> <li>The CommandService doesn't throw any global exception, each exception are wrapped in a CommandResponse.<\\/li> <\\/ul>\",new I5(J.a)).a),gmb(e,(umb(),rmb)),e),A6(a.gb));Mab(c,(f=new stb(2),qtb(f,(K=new Ytc,K.a+='On server side',new I5(K.a)).a),lw(f.L,$Jc,_Jc),f),A6(a.ib));Mab(c,(g=new imb((L=new Ytc,L.a+='<h4>Coming soon :<\\/h4> <ul> <li>J2EE CommandService resolving services in the JNDI<\\/li> <li>Spring CommandService resolving services in the ApplicationContext<\\/li> <\\/ul>',new I5(L.a)).a),gmb(g,rmb),g),A6(a.kb));Mab(c,(h=new stb(3),qtb(h,(M=new Ytc,M.a+='BasicCommandService',new I5(M.a)).a),lw(h.L,$Jc,_Jc),h),A6(a.mb));Mab(c,(i=new enc,dnc(i,(N=new Ytc,N.a+='<pre>\\n&lt;!-- Command service servlet --&gt;\\n&lt;servlet&gt;\\n  &lt;servlet-name&gt;commandService&lt;/servlet-name&gt;\\n  &lt;servlet-class&gt;fr.putnami.pwt.core.service.server.service.BasicCommandService&lt;/servlet-class&gt;\\n  &lt;init-param&gt;\\n      &lt;param-name&gt;services&lt;/param-name&gt;\\n      &lt;param-value&gt;fr.putnami.pwt.example.sample.server.service.PersonServiceImpl&lt;/param-value&gt;\\n  &lt;/init-param&gt;\\n&lt;/servlet&gt;\\n&lt;servlet-mapping&gt;\\n  &lt;servlet-name&gt;commandService&lt;/servlet-name&gt;\\n  &lt;url-pattern&gt;Sample/commandService&lt;/url-pattern&gt;\\n&lt;/servlet-mapping&gt;\\n<\\/pre>',new I5(N.a)).a),cnc(i,(Nnc(),Mnc)),i),A6(a.ob));Mab(c,(j=new stb(2),qtb(j,(O=new Ytc,O.a+='Service proxy',new I5(O.a)).a),lw(j.L,$Jc,_Jc),j),A6(a.qb));Mab(c,(k=new stb(3),qtb(k,(P=new Ytc,P.a+='Basic proxy',new I5(P.a)).a),lw(k.L,$Jc,_Jc),k),A6(a.f));Mab(c,(l=new enc,dnc(l,(Q=new Ytc,Q.a+='<pre>\\n// Remote proxy interface.\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {}\\n\\npublic PersonView(){\\n\\t// rebind the service in an instance. \\n\\tthis.personService = (PersonRemoteService) GWT.create(PersonRemoteService.class);\\n\\t// Bind callbacks with local handler methods.  \\n\\tthis.personService.bindService(this);\\n}\\n<\\/pre>',new I5(Q.a)).a),cnc(l,a.a),l),A6(a.i));Mab(c,(m=new enc,dnc(m,(R=new Ytc,R.a+='<pre>\\n@InjectService\\nPersonService personService;\\n<\\/pre>',new I5(R.a)).a),cnc(m,a.a),m),A6(a.k));Mab(c,(n=new stb(3),qtb(n,(S=new Ytc,S.a+='Standard async method',new I5(S.a)).a),lw(n.L,$Jc,_Jc),n),A6(a.o));Mab(c,(o=new enc,dnc(o,(T=new Ytc,T.a+='<pre>\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {\\n\\tvoid getPeople(String name, AsyncCallback&lt;Person&gt; callback);\\n}\\n<\\/pre>',new I5(T.a)).a),cnc(o,a.a),o),A6(a.r));Mab(c,(p=new stb(2),qtb(p,(U=new Ytc,U.a+='Callbacks',new I5(U.a)).a),lw(p.L,$Jc,_Jc),p),A6(a.t));Mab(c,(q=new stb(3),qtb(q,(V=new Ytc,V.a+='Success callback',new I5(V.a)).a),lw(q.L,$Jc,_Jc),q),A6(a.v));Mab(c,(r=new enc,dnc(r,(W=new Ytc,W.a+='<pre>\\n@AsyncHandler\\nvoid onSavePerson(Person result) {\\n\\t// Do something with the result\\n}\\n@AsyncHandler(method=\"savePerson\")\\nvoid customSavePersonCallback(Person result) {\\n\\t// Do an other hing with the result\\n}\\n<\\/pre>',new I5(W.a)).a),cnc(r,a.a),r),A6(a.A));Mab(c,(s=new stb(3),qtb(s,(X=new Ytc,X.a+='Faillure callback',new I5(X.a)).a),lw(s.L,$Jc,_Jc),s),A6(a.C));Mab(c,(t=new enc,dnc(t,(Y=new Ytc,Y.a+='<pre>\\n@AsyncHandler\\nvoid onSavePersonThrown(Throwable thrown) {\\n\\t// Do something with the exception\\n}\\n@AsyncHandler(method=\"savePerson\")\\nvoid customSavePersonThrown(Throwable thrown) {\\n\\t// Do something with the exception\\n}\\n<\\/pre>',new I5(Y.a)).a),cnc(t,a.a),t),A6(a.F));Mab(c,(u=new stb(2),qtb(u,(Z=new Ytc,Z.a+='Invoke a service',new I5(Z.a)).a),lw(u.L,$Jc,_Jc),u),A6(a.J));Mab(c,(v=new stb(3),qtb(v,($=new Ytc,$.a+='Single request',new I5($.a)).a),lw(v.L,$Jc,_Jc),v),A6(a.L));Mab(c,(w=new imb((ab=new Ytc,ab.a+='<h4>Note : <\\/h4> <p> All proxy methods return null. the result is be passed to the <code>AsyncHandler<\\/code> <\\/p>',new I5(ab.a)).a),gmb(w,rmb),w),A6(a.N));Mab(c,(A=new enc,dnc(A,(bb=new Ytc,bb.a+='<pre>\\n@UiHandler(\"saveButton\")\\nvoid onSaveClick(ClickEvent event){\\n\\tPerson personToSave = ...\\n\\t// Call the remote service\\n\\tthis.personService.savePerson(personToSave);\\n}\\n<\\/pre>',new I5(bb.a)).a),cnc(A,a.a),A),A6(a.P));Mab(c,(B=new stb(3),qtb(B,(cb=new Ytc,cb.a+='Multiplex requests',new I5(cb.a)).a),lw(B.L,$Jc,_Jc),B),A6(a.R));Mab(c,(C=new enc,dnc(C,(db=new Ytc,db.a+='<pre>\\nvoid load100Persons(){\\n\\t// allow to stack requests.\\n\\tCommandController.get().setSuspended(true);\\n\\tfor(int i = 0 ; i &lt; 100 ; i++){\\n\\t\\t// does not make any http request.\\n\\t\\tthis.personService.getPerson(i);\\n\\t}\\n\\t// Send the 100 requests over a single http request.\\n\\t// For each request the callback will be called.\\n\\tCommandController.get().flush();\\n}\\n<\\/pre>',new I5(db.a)).a),cnc(C,a.a),C),A6(a.T));Mab(c,(D=new stb(3),qtb(D,(eb=new Ytc,eb.a+='Lazy commands',new I5(eb.a)).a),lw(D.L,$Jc,_Jc),D),A6(a.V));Mab(c,(F=new enc,dnc(F,(fb=new Ytc,fb.a+='<pre>\\ninterface PersonRemoteService extends ServiceProxy&lt;PersonView, PersonService&gt;, PersonService {\\n\\t@LazyCommand\\n\\tPerson getPerson(Long id);\\n}\\n<\\/pre>',new I5(fb.a)).a),cnc(F,a.a),F),A6(a.X));Mab(c,(G=new stb(2),qtb(G,(gb=new Ytc,gb.a+='Events',new I5(gb.a)).a),lw(G.L,$Jc,_Jc),G),A6(a.Z));Mab(c,new imb((hb=new Ytc,hb.a+='<h4>Note :<\\/h4> <p> If the method is annotated as <code>@QuietCommand<\\/code> events are not fired. <\\/p>',new I5(hb.a)).a),A6(a._));Mab(c,(H=new enc,dnc(H,(ib=new Ytc,ib.a+='<pre>\\nCommandController.get().addCommandRequestHandler(requestHandler);\\nCommandController.get().addCommandResponseHandler(responseHandler);\\n<\\/pre>',new I5(ib.a)).a),cnc(H,a.a),H),A6(a.db));a.rb.j=c;return c}\nfunction Zcc(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F){var G;G=new Ytc;G.a+=PGc;Vtc(G,X5(a));G.a+=\"'><\\/span> <p> This framework is based on a invisible command pattern. This pattern allow to pipe all requests on unique servlet. <\\/p> <p> To make it work you need to: <\\/p> <ul> <li>On the client side you just have to generate a <code>ServiceProxy<\\/code> from the service interface.<\\/li> <li>On the server side you just have to instantiate a single servlet implementing the <code>CommandService<\\/code><\\/li> <\\/ul> <p> When you make a service call, the request flow is: <\\/p> <ol> <li>The <code>ServiceProxy<\\/code> builds one <code>CommandRequest<\\/code><\\/li> <li>The <code>CommandRequest<\\/code> is submited to the <code>CommandController<\\/code>.<\\/li> <li>The <code>CommandController<\\/code> sends a <code>CommandRequestEvent<\\/code> to notify handlers.<\\/li> <li>Then <code>CommandController<\\/code> encodes the <code>CommandRequest<\\/code> in a RPC payload.<\\/li> <li>The <code>CommandController<\\/code> sends the payload over one <code>HttpTequest.<\\/code><\\/li> <li>On the server side, the <code>CommandService<\\/code> handles the <code>CommandRequest<\\/code><\\/li> <li>The <code>CommandRequest<\\/code> is dispatched it to the responsive <code>CommandExecutor<\\/code>.<\\/li> <li>The <code>CommandExecutor<\\/code> invokes the service<\\/li> <li>The <code>CommandExecutor<\\/code> builds a <code>CommandResponse<\\/code> with the result or the exception.<\\/li> <li>The <code>CommandExecutor<\\/code> returns the <code>CommandResponse<\\/code><\\/li> <li>Then <code>CommandService<\\/code> writes <code>CommandResponse<\\/code> on the <code>HttpResponse<\\/code>.<\\/li> <li>Back on the client side, the <code>CommandController<\\/code> handles the <code>CommandResponse<\\/code>.<\\/li> <li>The <code>CommandResponse<\\/code> result or exception is dispatched the to differents binded callbacks.<\\/li> <li>Finally the <code>CommandController<\\/code> sends a <code>CommandResponseEvent<\\/code> to notify handlers.<\\/li> <\\/ol> <span id='\";Vtc(G,X5(b));G.a+=OGc;Vtc(G,X5(c));G.a+=\"'><\\/span> <p> On the server side all requests pass through the <code>CommandService<\\/code>.  <br> The <code>CommandService<\\/code> is in charge to dispatch the <code>CommandRequest<\\/code> to a <code>CommandExecutor<\\/code>. <br> Then <code>CommandExecutor<\\/code> handles <code>CommandRequest<\\/code>, invokes the targeted service then returns a <code>CommandResponse<\\/code>. <\\/p> <span id='\";Vtc(G,X5(d));G.a+=OGc;Vtc(G,X5(e));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> The <code>BasicCommandService<\\/code> is a basic implementation allowing to instantiate services. <\\/p> <\\/div> <span id='\";Vtc(G,X5(f));G.a+=fKc;Vtc(G,X5(g));G.a+=OGc;Vtc(G,X5(h));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> On the client side you first need to generate a proxy with the following steps: <\\/p> <ol> <li>Declare an interface which extends <code>ServiceProxy&lt;HANDLER, SERVICE&gt;<\\/code>.  <br> <strong>SERVICE<\\/strong> is the interface of the remote service. <br> <strong>HANDLER<\\/strong> is the class on which async callbacks are dispatched. <\\/li> <li>Generate the proxy with <code>GWT.create(...)<\\/code>.  <br> The rebind mechanism will generate the code to make commands and callbacks. <\\/li> <li>Then finally then bind the proxy with the handler <code>proxy.bindService(hadler)<\\/code>. <br> Attach the proxy to the handler, in order to properly dispatch the async callbacks. <\\/li> <\\/ol> <\\/div> <span id='\";Vtc(G,X5(i));G.a+=\"'><\\/span> <p>If you use the <a href='#!Injection'>Injection feature<\\/a> (if the view implements the <code>View<\\/code> interface), you can use the ()very simple) following :<\\/p> <span id='\";Vtc(G,X5(j));G.a+=fKc;Vtc(G,X5(k));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> To declare standard async method, you have to : <\\/p> <ol> <li>Override the targeted method in the proxy interface.<\\/li> <li>Append an <code>AsyncCallback&lt;RETURN_TYPE&gt;<\\/code> parameter.<\\/li> <li>Set the return type to <strong>void<\\/strong>.<\\/li> <\\/ol> <\\/div> <span id='\";Vtc(G,X5(l));G.a+=fKc;Vtc(G,X5(m));G.a+=\"'><\\/span> <p> Thanks to the <code>@AsyncHandler<\\/code> you don't need to declare the verbose <code>AsyncCallback<\\/code>.  <br> The annoted methods of the handler are scanned and used to generate the callbacks. <\\/p> <div class='showcase-sample-block'> <span id='\";Vtc(G,X5(n));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The service method name is resolved by convention or with the attribute <code>@AsyncHandler(method=\\\"savePerson\\\")<\\/code>. <\\/p> <p> The convention is : on{methodName with first letter in upper case}[Event]? <\\/p> <p> The method must return void and have one parameter with the expected return type. <br> If the return type is <code>void<\\/code> then the parameter must be <code>Void<\\/code>. <br> If the return type is primitive then the parameter type is the Object type representation. <\\/p> <\\/div> <span id='\";Vtc(G,X5(o));G.a+=OGc;Vtc(G,X5(p));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The service method name is resolved by convention or with the attribute <code>@AsyncHandler(method=\\\"savePerson\\\")<\\/code>. <\\/p> <p> The convention is : on{methodName with first letter in upper case}[Thrown]? <\\/p> <p> The method return void and must have one Throwable parameter. <\\/p> <\\/div> <span id='\";Vtc(G,X5(q));G.a+=gKc;Vtc(G,X5(r));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <span id='\";Vtc(G,X5(s));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> Server method invokation is a pushover, you just have to invoke the methods on the <code>ServiceProxy<\\/code> then all concerned <code>AsyncHandler<\\/code> are called . <\\/p> <\\/div> <span id='\";Vtc(G,X5(t));G.a+=OGc;Vtc(G,X5(u));G.a+=OGc;Vtc(G,X5(v));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> The <code>CommandController<\\/code> helps you suspend requests. When it is flushed the pending requests are collected and sent in a single HTTP Request to the server. On response, each <code>@AsyncHandler<\\/code> is properly called. <\\/p> <\\/div> <span id='\";Vtc(G,X5(w));G.a+=OGc;Vtc(G,X5(A));G.a+=\"'><\\/span> <div class='showcase-sample'> <p> Use the <code>LazyCommand<\\/code> annotation to stack the request untill the next \\\"no lazy\\\" request is done or <code>CommandController<\\/code> is flushed.  <\\/p> <\\/div> <span id='\";Vtc(G,X5(B));G.a+=gKc;Vtc(G,X5(C));G.a+=\"'><\\/span> <div class='showcase-sample-block'> <div class='showcase-sample'> <p> Events are fired when <code>CommandController<\\/code> sent and received request. <br> <\\/p> <p> Usage examples: <\\/p> <ul> <li>Make stats.<\\/li> <li>Display a request pending modal.<\\/li> <li>Reset timer to close user session.<\\/li> <\\/ul> <span id='\";Vtc(G,X5(D));G.a+=gKc;Vtc(G,X5(F));G.a+=VJc;return new I5(G.a)}\ns3(1364,46,WJc);var zZ=xrc(JIc,'ServerCallsPage',1364,UU);s3(902,1364,XJc,Tcc);_.th=function Ucc(a,b){K$b(this);b.xe(this)};var vZ=xrc(JIc,'ServerCallsPage_Injector',902,zZ);s3(990,1,{},Xcc);var wZ=xrc(JIc,'ServerCallsPage_ServerCallsPageTemplateBinder_UiBinderLocalized_BinderImpl/Widgets',990,B1);var _cc;s3(647,1,rIc);_.Je=function jdc(){var a;!(a5(),_cc)&&(_cc=new Tcc);a=new N$b;vjb(a,_cc);ojb(this.a,a)};uEc(Vt)(11);\n//# sourceURL=Documentation-11.js\n")
